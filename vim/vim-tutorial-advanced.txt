Original: www.guckes.net/talks/vim.small_commands.txt
title: Sven Guckes: "[Vim] Small Commands - only a few keystrokes away.."

= talk =

title:      Small Commands
motto:      "only a few keystrokes away.."
url:        http://www.guckes.net/vimberlin/small_commands.txt
.           http://www.guckes.net/vimberlin/small_commands.txt.html
author:     Sven  Guckes

= abstract =

all editing requires some changes - and many are done
with just a few of those "small commands" here and there.

this starts with "jump commands" which simply move the cursor,
so trying this should not change any of the text within.

then there are some changes, usually deletions, because
you should be able to see the difference to the text.

the dot commands repeats the last change.. very powerful!

you should also know some commands in visual mode
and for managing windows because these are handy.

of course there are a lot more topics - but this is
about small commands, ie only a few keystrokes away.

i use all of these many times with every editing i do. enjoy!

= jumps =

a "jump" is a command which moves/repositions
the cursor (within the current window).
as vim is a modal editor, it easily allows to
combine commands (copying+pasting) with moves.
(we shall see about those commands later..)

basic movement/jumps of the
cursor by one character/line:

    hjkl    jump left/down/up/right

picture:
       ^
  <- hjkl ->
      v

    0       jump onto first character ("column zero")
    $       jump onto last  character (mnemonic?)

read the vimtutor file about basic commands:
    :help vimtutor

= Number Prefix =

concept: number prefix
type digits - and they'll add up to a number.  then
type a command - and the command is usually repeated.

    3j      jump down by three lines

the 'G' ("goto line") commands uses
a number prefix as a line number:

     1G     jump to first line
    23G     jump to line #23
      G     jump to last line

note: the default line number is the *last* line.

= jump by words/WORDS =

jump to begin-of-word (BOw) and end-of-word (EOw):
    b       jump to previous BOw
    e       jump to next     EOw
    w       jump to next     BOw

jump to begin-of-word (BOW) and end-of-word (EOW):
    B       jump to previous BOW
    E       jump to next     EOW
    W       jump to next     BOW

mind you:
    bew     jump based on *words*   ":help iskeyword"
    BEW     jump based on *WORDS*   non-blank characters
hint: use BEW - it's much nicer! :-)

mnemonic for users who know a bit of German: BEWegen

= jump within window =

jump to the home, middle, and last line on current window:

    H   jump to highest line of current window
    M   jump to middle  line of current window
    L   jump to last    line of current window

    HML = high/middle/last

= jumping by searches =

"search for string" instead of jumping:
    /foo<ENTER>     search for next     "foo"
    ?bar<ENTER>     search for previous "bar"

search offset:
    /foo.*bar/b     search for next match, placing cursor on beginning
    /foo.*bar/e     search for next match, placing cursor on end

find the next match, reusing  last search pattern:
    n   jump to next match of last search - in same     direction
    N   jump to next match of last search - in opposite direction

use the current word (INcluding word boundaries) to search for:
    *   searches for next     match of current word
    #   searches for previous match of current word

use the current word (EXcluding word boundaries) to search for:
    g*  searches for next     match of current word
    g#  searches for previous match of current word

went too far? jump back! (vim keeps a list of places)
    CTRL-O  jump back    in jump list
    CTRL-I  jump forward in jump list

see also:
    :help CTRL-O
    :help :jumps

see also:
    what is the name of that character, anyway?
    http://de.wikipedia.org/wiki/Rautenzeichen
    :help search-offset

= single character =

a little faster when searching only for a single character:

jumping onto/before the next 'X' character:
    fX  jump onto next      character 'X'
    FX  jump onto previous  character 'X'
    t)  jump   to next      character ')'
    T(  jump   to previous  character '('

example: ".. consider a function foo(X,Y) .."

repeating these search commands
are done with comma and semicolon:

    ;       Repeat latest fFtT in last used direction
    ,       Repeat latest fFtT in opposite  direction


= scrolling =

idea: dont move the cursor, ie
only change the view on the buffer
without leaving the current position.

scrolling up/down:
    CTRL-E + CTRL-Y     "extra lines"

repositioning the current line on the current window:
    zt      move current line to top    line
    zz      move current line to middle line
    zb      move current line to bottom line

repositioning the current line left/right:
note: ":set nowrap" for the following to work!
    zh      move window content to the left
    zl      move window content to the right

    zH      move window content left  by half a window width
    zL      move window content right by half a window width

see also:
  :help z

paging:

paging by full screens:
    CTRL-B  scroll full page backwards (like PgUp)
    CTRL-F  scroll full page forwards  (like PgDn)

paging by half screens:
    CTRL-U  scroll 1/2  page backwards ("up")
    CTRL-D  scroll 1/2  page backwards ("down")

see also:
  :help scrolloff

= switching modes =

switch from command mode into
INSERT (append/insert/open) mode:
    aio     simply switch.. you know.
    here AIO     includes jump to BOL/EOL

    A       $a      append at EOL
    I       ^i      insert at first non-whitespace

you might have expected 'I' to work as '0i' - but
inserting at the first non-whitespace is a feature.

switch from insert mode to command mode
for only the next command:
    CTRL-O

example:
    <c-o>^  jump to first non-whitespace
    <c-o>$  jump to end-of-line (EOL)

see also:
  :help i_CTRL-O

= changes =

effective changes to the buffer content:

    C       c$  change rest of current line
    D       d$  delete rest of current line
    S       cc  substitute the current line

    c0      change to beginning of current line

concept:    change := delete + insert
so a "change" command first deletes some text
and after that switches into insert mode.  so it
saves you another command for that mode switch.

delete from current line
to the end of the buffer:
    dG

please use this when editing emails
on mailing lists - thankyouverymuch!

delete current and the adjacent next/previous line:
    dj dk

deleting a bunch of lines:
    10dd
    99dd
     9dd
     9dj :-)  deletes 10 lines, too.

     d10j     prefix to 'j' command

delete the current WORD:
    diW

delete to start/end of current paragraph:
    d{      delete to start of current paragraph
    d}      delete to end   of current paragraph

problem: the deletion takes away an empty line as well.

vi style:
    {+ma    jump to previous empty line, advance one line, mark with 'a'
    }-mb    jump to next     empty line, go back one line, mark with 'b'
    :'a,'bd "from line marked by 'a' unto line marked by 'b' - "delete"'
            shorter: "from line a unto line b - delete'

command line (without using marks):
    :?^$?+,/^$/-1d

see also:
    :help ex-cmd-index

= using text objects =

deleting  the current paragraph
irrelevant of current position:
    dap

indenting the current paragraph:
    >ip

mapping that command to F4:
    :map <f4> >ip

deleting inner/all of bracketed text:
    d i/a ([{<>}])

examples:
command  description
ci)      this text is (inside of) outside of brackets
cit      <pre>  this is <b>preseved text</b> which must be changed </pre>

see also:
  :help text-objects

= break/join =

breaking the line on a space:
    r<enter>

joining lines without a space:
    gJ

example:
this line is/
was broken

note:
    vi: no gqv commands
    vim:   gqv commands! :-)

= dot! =

the DOT command!
it repeats the last change command.

see also:
  :help .

= visual mode =

(1) visually select the text (block/linewise)
(2) type 'y' to copy or 'd' to delete

    viW     visualize inner WORD
    vis     visualize inner sentence
    vip     visualize inner paragraph

example:

  Every people deserves the politicians it elects.   Corollary:
  Everybody uses the editor/mailer/program/OS he deserves.

example:
visual block mode...
  one two three four five six seven eight nine ten
  one two three four five six seven eight nine ten
  one two three four five six seven eight nine ten
  one two three four five six seven eight nine ten
  one two three four five six seven eight nine ten
  one two three four five six seven eight nine ten
  one two three four five six seven eight nine ten


= windows =

more windows!
(*not* vi compatible ;)

  CTRL-W n    :new
  CTRL-W s    :split
  CTRL-W v    :vsplit
  CTRL-W c    :close
  CTRL-W o    :only

  CTRL-W f    HOMEWORK! :-)

example:
  take a look into the file /etc/passwd

see also:
  :help CTRL-W

= end? =

    :write  :w
    :quit   :q
    :wq     :w + :q
    :x      "eXit"  only writes when necessary

but why end with four keystrokes (":wq" + RETURN)
or three keystrokes (":x" + RETURN) when you
can simply quit with *two* keystrokes?!

    ZZ

= thanks =

this is the official end to this lecture/talk.
thank you for listening! :-)

would be great to get some feedback.

the following stuff is simply
to make your mouth water.. ;-)

= mappings =

mappings assign to keys either
other keys or key sequences.

a quick way to "save" (:write) the current
buffer's contents to its associated file:

    : map ,,         :w<cr>
    :imap ,, <ctrl-o>:w<cr>

= filtering =

rot13: change text by turning
the alphabet by half its size..

    :vmap <f2>  !tr A-Za-z N-ZA-Mn-za-m<cr>

example:
    guckes
    thpxrf

rot13 is also available internally as "g?" :-)

#include talk on filtering with all those
tools available on all UNIXish systems..

= registers =

there are *26* clipboards - from 'a' to 'z'!

|   "a    use  register 'a' (start of command)
|   "ap   from register 'a' - put
|   "ay   into register 'a' - yank

|   "adap     use register 'a' to delete current paragraph into
              or: cut current paragraph to register 'a'

note:
when vim shuts down then it can save all of these info
to a file and pick them up again at the next startup.

see also:
  :help session-file

idea:
create a mapping to copy the current
text object to the gui clipboard.

= command line =

    :b 23           switch to buffer #23
    :e #            edit "the alternate file"
    :r /etc/passwd  read/insert contents of file
    :r !date        read/insert output from "date" command
    :w %.bak        write a copy of current buffer to $filename.bak
    :w !xsel -b     write the current buffer to the X clipboard
    :'<,'>w !wc -c  write a copy of the block to "wc" to count characters

see also:
  :help cmdline-special

= abbreviations =

abbreviations may have a non-constant
expansion using an internal function:
    iab Ytime <C-R>=strftime("%H:%M")<CR>
    iab YDate <C-R>=strftime("%Y-%m-%d")<CR>
    iab YDATE <C-R>=strftime("%a %b %d %T %Z %Y")<CR>

example:
    Ytime -> 23:42
    YDate -> 2012-11-22
    YDATE -> Sat Dec 08 23:42:05 CET 2012

= tags =

think "bookmarks", ie a word
for a position in a filename.

the structure of a tags file:
abbr/tag TAB filename TAB command

examples:
  :ta ta        jump into tags file
  :ta cal       jump to the calendar
  :ta fon       jump to phone list
  :ta sig       jump to signatures

aside:
calendar tool "ccal" ->
http://packages.debian.org/search?keywords=ccal
it's now a python command!
http://ghom.niij.org/ccal.py.git
thanks to Michael Zeltner :-)

= sessions =

"remember, remember.. the 22nd of november.."

a session file contains your commands,
searches, clipboards/registers,
the buffer/file list - and much more!

viminfo contents:
histories (command line, search patterns, input-line),
contents of registers, marks and file-marks, last
search/subst pattern, buffer list, global variables.

  :help session-file
  :help viminfo-file

example:
  :set vi=\"200,%,'200,/100,:100,@100,f1,h,n~/.vim/viminfo

= outlook =
suggested topics for more talks:

* color schemes / syntax file
* command line commands (:g + :s)
* filters
* registers
* regular expressions
* session files
* tags

please share your knowledge with others!

= links =

* coloring by sven.vim   (todo)
* Newsgroup comp.editors (todo)
* Sven's vimrc on github (todo)

= todo =

* tab + detab
* :global command

what's missing?  please tell me!

= events =

this talk had been given at these events/venues:

date:       2012-11-22 20:23-21:10 plus q+a until 21:30
group:      "VimBerlin" - Vim User Group Berlin
announce:   http://vimberlin.de/november-2012-meetup/
announce:   http://lanyrd.com/2012/vimberlin-2-november/
contact:    2012-11-22-vimtalk@guckes.net

date:       2012-12-06 22:23-23:42 plus q+a until 02:42
group:      "Metalab" - Hackerspace in Vienna
announce:   https://www.metalab.at/wiki/2012-12-06_Nikolo_Vim
contact:    2012-12-06-vim-small-commands@guckes.net

date:       2012-12-13 20-21h
group:      "progressbar" - Hackerspace in Bratislava
announce:   http://iPir.at/lcr
contact:    2012-12-13-vim-small-commands@guckes.net

date:       2015-05-24 10-12h
group:      ducc.it event at TIM WCAP Accelerator in Milano
announce:   http://ducc.it/programma
contact:    2015-09-19-vim-small-commands@guckes.net

date:       2015-09-19 21-24h
group:      "toppoint" - Hackerspace in Kiel.de
announce:   none. spontaneous choice.
contact:    2015-09-19-vim-small-commands@guckes.net

= TheEnd =

Latest change: Di Sep 29 17:00:00 CEST 2015
the previous line can be updated with ",L":
    map ,L  1G/Latest change:\s*/e+1<CR>CYDATE<ESC>

<!-- vim: set et ft=sven tw=123 nowrap: THPXRF EOF -->
